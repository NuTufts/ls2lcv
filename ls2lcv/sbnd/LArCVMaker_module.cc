////////////////////////////////////////////////////////////////////////
// Class:       LArCVMAker
// Module Type: analyzer
// File:        LArCVMaker_module.cc
//
// Generated at Wed Oct 15 18:41:39 2014 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

// ART includes
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
// #include "ubcore/Geometry/UBOpChannelTypes.h"
// #include "ubcore/Geometry/UBOpReadoutMap.h"
// #include "ubobj/Trigger/ubdaqSoftwareTriggerData.h"
// #include "ubobj/MuCS/MuCSData.h"
// #include "ubobj/MuCS/MuCSRecoData.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"

#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/geo_vectors_utils_TVector.h" // toTVector3()
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "lardataobj/RawData/TriggerData.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/EndPoint2D.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/PCAxis.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/AnalysisBase/FlashMatch.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "nusimdata/SimulationBase/MCFlux.h"
#include "nusimdata/SimulationBase/GTruth.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/OpticalDetectorData/FIFOChannel.h"
#include "lardataobj/OpticalDetectorData/OpticalTypes.h"
#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "larcoreobj/SummaryData/POTSummary.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusService.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusProvider.h"
//// New Data Product
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"

// LArLite include
#include "larlite/Base/GeoTypes.h"
#include "larlite/DataFormat/storage_manager.h"
#include "larlite/DataFormat/potsummary.h"
#include "larlite/DataFormat/simphotons.h"
#include "larlite/DataFormat/chstatus.h"
#include "larlite/DataFormat/DataFormatException.h"
#include "larlite/LArUtil/LArUtilConfig.h"
#include "larlite/LArUtil/Geometry.h"

// LArCV include
#include "larcv/core/DataFormat/IOManager.h"
#include "larcv/core/DataFormat/EventImage2D.h"

// std 
#include <vector>
#include <string>
#include <iostream>
#include <fstream>

// ROOT
#include <TTimeStamp.h>
#include <TString.h>

class LArCVMaker;

class LArCVMaker : public art::EDAnalyzer {
public:
  explicit LArCVMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LArCVMaker(LArCVMaker const &) = delete;
  LArCVMaker(LArCVMaker &&) = delete;
  LArCVMaker & operator = (LArCVMaker const &) = delete;
  LArCVMaker & operator = (LArCVMaker &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void endJob() override;
  void beginSubRun(const art::SubRun& sr) override;

private:

  /// storage_manager from larlite
  ::larcv::IOManager _mgr;

  /// Boolean to enable unique file name
  std::string fOutFileName;
  /// Stream name
  std::string fStreamName;
  /// RawDigitproducer name (if needed) for ChStatus 
  std::string _chstatus_rawdigit_producer;
  /// Factor with which to downsample the time dimension
  int _downsample_factor;
};


LArCVMaker::LArCVMaker(fhicl::ParameterSet const & p) 
  : EDAnalyzer(p),
    _mgr( larcv::IOManager::kWRITE ),
    _downsample_factor(1)
 // More initializers here.
{
  fStreamName = p.get<std::string>("stream");

  _chstatus_rawdigit_producer = p.get<std::string>("RawDigit4ChStatus","");

  _downsample_factor = p.get<int>("DownsampleFactor",4);

  fOutFileName = p.get<std::string>("out_filename","out_sbnd_larcv.root");
  if(p.get<bool>("unique_filename")) {
    TString tmp_fname(p.get<std::string>("out_filename","out_sbnd_larcv.root"));
    tmp_fname.ReplaceAll(".root","");
    TTimeStamp ts;
    fOutFileName = Form("%s_%08d_%06d_%06d.root",tmp_fname.Data(),ts.GetDate(),ts.GetTime(), (int)(ts.GetNanoSec()/1.e3));
  }
  _mgr.set_out_file(fOutFileName);

  //geometry setup: use larlite until I find out how to use the Geometry Service
  std::cout << "Load SBND Geometry" << std::endl;
  larutil::LArUtilConfig::SetDetector( larlite::geo::kSBND );

}

void LArCVMaker::beginJob() {
  _mgr.initialize();
}

void LArCVMaker::endJob() {
  _mgr.finalize();
}

void LArCVMaker::beginSubRun(art::SubRun const& sr)
{
}

void LArCVMaker::analyze(art::Event const & e)
{

  _mgr.set_id(e.id().run(),
	      e.id().subRun(),
	      e.id().event());

  auto llgeom = larlite::larutil::Geometry::GetME();
  
  const int nCryos = llgeom->Ncryostats();
  int nTPCs   = 0;
  int nPlanes = 0;
  unsigned int max_wires_per_plane = 0;
  for (int icryo=0; icryo<nCryos; icryo++) {
    for ( int itpc=0; itpc<(int)llgeom->NTPCs(icryo); itpc++ ) {
      nTPCs++;
      for (int iplane=0; iplane<(int)llgeom->Nplanes(itpc,icryo); iplane++) {
	nPlanes++;
	if ( llgeom->Nwires(iplane,itpc,icryo)>max_wires_per_plane )
	  max_wires_per_plane = llgeom->Nwires(iplane,itpc,icryo);
      }
      std::cout << "Cryo[" << icryo << "] TPC[" << itpc << "] nplanes=" << llgeom->Nplanes(itpc,icryo) << std::endl;
    }
  }
  std::cout << "Total number of cryostats: " << nCryos << std::endl;
  std::cout << "Total number of TPCs: " << nTPCs << std::endl;
  std::cout << "Total number of Planes: " << nPlanes << std::endl;
  std::cout << "Max wires per plane: " << max_wires_per_plane << std::endl;  

  // ==== LARSOFT PRODUCTS ===============
  // Make a list of larsoft products we want to translate into larlite

  // Deconvolved wire signals
  std::string wireproducer = "Reco1Comm";
  std::string stage_name = "caldata";
  std::vector< std::string > wire_tagname_v = {""};

  std::vector< art::InputTag > wire_tag_v;
  for (auto& tagname : wire_tagname_v ) {
    art::InputTag wire_tag( stage_name, tagname, wireproducer );
    wire_tag_v.push_back( wire_tag );
  }

  // *************************************************************************
  // ***  SINGLE EVENT PROCESSING BEGIN  *************************************
  // *************************************************************************
  
  
  //mf::LogVerbatim("gallery2larcv_sbnd") << "This is event " << event.fileEntry() << "-" << event.eventEntry();

  auto ev_wireout = (larcv::EventImage2D*)_mgr.get_data(larcv::kProductImage2D,"wire");

  std::vector< larcv::Image2D > adc_v;
  
  // we get the wire data, find longest signal size
  int max_ticks_per_channel = 0;
  for ( auto& wire_tag : wire_tag_v ) {
    auto pWireVec = e.getValidHandle< std::vector<recob::Wire> >(wire_tag);
    //int nwires = pWireVec->size();    
    for ( auto const& wire : *pWireVec )  {
      size_t nsignal = wire.Signal().size();
      if ( (int)nsignal>max_ticks_per_channel )
	max_ticks_per_channel = (int)nsignal;
    }
    
  }
  std::cout << "Max ticks per channel: " << max_ticks_per_channel << std::endl;
	  
  int output_nticks = max_ticks_per_channel/_downsample_factor;
  int output_nticks_pre = max_ticks_per_channel;
  if ( _downsample_factor>1 && max_ticks_per_channel%_downsample_factor!=0 ) {
    output_nticks += 1;
    output_nticks_pre = _downsample_factor*output_nticks;
  }
  std::cout << "Output ticks per channel, fit with downsampler : " << output_nticks << std::endl;
  std::cout << "Output ticks per channel, pre-downsampler : " << output_nticks_pre << std::endl;
  
  // we allocate the space for the images.
  for (int icryo=0; icryo<(int)llgeom->Ncryostats(); icryo++ ) {
    for (int itpc=0; itpc<(int)llgeom->NTPCs(icryo); itpc++) {
      for (int iplane=0; iplane<(int)llgeom->Nplanes(itpc,icryo); iplane++) {
	int index = llgeom->GetSimplePlaneIndexFromCTP( icryo, itpc, iplane );

	larcv::ImageMeta meta( max_wires_per_plane, output_nticks_pre,
			       (int)output_nticks_pre, (int)max_wires_per_plane,
			       0.0, 0.0, index );
	larcv::Image2D img(meta);
	img.paint(0.0);
	std::cout << "blank made: " << meta.dump() << std::endl;
	adc_v.emplace_back( std::move(img) );
      }
    }
  }
  
  // populate the images
  for ( auto& wire_tag : wire_tag_v ) {

    auto pWireVec = e.getValidHandle< std::vector<recob::Wire> >(wire_tag);
    //size_t nwires = pWireVec->size();
    
    for ( auto const& wire : *pWireVec )  {
      std::vector<float>  signal = wire.Signal();
      if ( signal.size()==0 )
	continue;

      raw::ChannelID_t   channel = wire.Channel();
      larlite::geo::WireID wireid = llgeom->ChannelToWireID(channel);

      int wid     = wireid.Wire;
      int planeid = wireid.Plane;
      int tpcid  = wireid.TPC;
      int cryoid = wireid.Cryostat;
      int lcvplaneid = llgeom->GetSimplePlaneIndexFromCTP( cryoid, tpcid, planeid );
	
      //std::cout << "  wire (p,t,c)=(" << planeid << "," << tpcid << "," << cryoid << ")" << std::endl;
      auto& img = adc_v.at(lcvplaneid);
      //if ( signal.size()>max_ticks_per_channel ) {
      //std::cout << "CH " << channel << ": num wires=" << wire_v.size() << " num ticks=" << signal.size() << std::endl;
      //}
      img.copy( 0, wid, signal, std::min((int)signal.size(),(int)output_nticks_pre) );
      //std::cout << "CH " << channel << ": no wires=" << wire_v.size() << std::endl;
      
      //std::cout << "max signal size: " << nmaxsignal << std::endl;
    }//end of loop over wire-vector
  }//end of wire-tag loop
  
  for (auto& img : adc_v ) {
    
    // compress image first
    if ( _downsample_factor>1  )
      img.compress( output_nticks, max_wires_per_plane, larcv::Image2D::kSum );
    
    int nabove = 0;
    for ( auto const& pixval : img.as_vector() ) {
      if ( pixval>5.0 )
	nabove++;
      
      if (nabove>10) {
	break;
      }
    }
    
    if ( nabove>10 ) {
      std::cout << "saving image with content: " << img.meta().dump() << std::endl;
      ev_wireout->Emplace( std::move(img) );
    }
  }
  
  _mgr.save_entry();
  
}

DEFINE_ART_MODULE(LArCVMaker)
